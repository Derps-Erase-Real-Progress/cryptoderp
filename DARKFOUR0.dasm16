; DCPU-16 Alleged Ron (K)ode 4
; Authors: Sasha Crofter, dylwhich
;
; description
; This particular demo writes two lines
; of white, blank characters to 0x8000
; and on, which is the expected screen
; memory. It then performs a cypher
; using our method on those lines.
; It then copies the lines elsewhere
; onscreen, and decyphers those.

;testrun

SET [0x4FF8], 0xe5 ;keybyte 0
SET [0x4FF9], 0x8a
SET [0x4FFA], 0x91
SET [0x4FFB], 0x0F
SET [0x4FFC], 0xbc
SET [0x4FFD], 0xd9
SET [0x4FFE], 0xc5
SET [0x4FFF], 0x37 ;keybyte 7

SET A, 0x4FF8
SET B, 8
SET C, 0x5000
JSR init_DARKFOUR

;BRK ;successful

SET A, 0x8000
SET B, 32
SET C, 0x5000
JSR DARKFOUR

BRK ;

SET PC, EOF


:DARKFOUR ; (dataloc, datalen, tableloc)
SET PUSH, X
SET PUSH, Y
SET PUSH, I
SET PUSH, J

ADD B, A ;make B the endpoint of the target data

SET I, 0
SET J, 0

:DARKFOUR_loop     ;TODO standardize
JSR DARKFOUR_lookup
XOR A, [Y]         ;encypher
ADD A, 1           ;iterate
IFG B, A
SET PC, DARKFOUR_loop

SET J, POP
SET I, POP
SET Y, POP
SET X, POP
SET PC, POP ;DARKFOUR

:DARKFOUR_lookup ; (I=index0, J=index1; Y=locout)

AND I, 0x00FF
BOR I, C     ;make I an index in the table

ADD J, [I]
AND J, 0x00FF
BOR J, C     ;make J an index in the table

SET Y, [I]
ADD Y, [J]   ;set Y to [I] + [J]

SET X, [I]
SET [I], [J]
SET [J], X   ;switch [I] and [J]

ADD I, 1     ;iterate I

AND Y, 0x00FF
BOR Y, C     ;make Y an index in the table

SET PC, POP ;DARKFOUR_lookup

:init_DARKFOUR ; (keyloc, keylen, tableloc)
SET PUSH, I
SET PUSH, J
SET PUSH, Z
SET I, 0
SET J, 0
SUB B, 1

:init_DARKFOUR_maketable ; initialize table
AND I, 0x00FF
BOR I, C
SET Z, I
AND I, 0x00FF
SET [Z], I
ADD I, 1
IFG 0x00FF, I
SET PC, init_DARKFOUR_maketable


SET I, 0
SET J, 0
:init_DARKFOUR_usekey ; make bytes
BOR I, C     ;make I an index on the table
             ;TODO try AND I, C?
             ;
             ;     try AND I, 0x0FF
             ;         AND I, C

ADD J, [I]   ;begin assembling J

SET Z, I     ;get key byte
AND Z, B     ;
BOR Z, A

ADD J, [Z]   ;add key byte

AND J, 0x00FF
BOR J, C     ;make J an index on the table

SET Z, [I]   ;swap values I and J
SET [I], [J]
SET [J], Z

ADD I, 1     ;increment I
AND I, 0x00FF;make I easy to compare
IFG 0x00FF, I;continue if I has not reached
SET PC, init_DARKFOUR_usekey ;the end of the table

SET Z, POP
SET J, POP
SET I, POP
SET PC, POP ;init_DARKFOUR

:EOF SET PC, 0xFFFF ;crash
