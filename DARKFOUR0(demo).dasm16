; DCPU-16 Alleged Ron (K)ode 4
; Authors: Sasha Crofter
; Repository: https://github.com/Derps-Erase-Real-Progress/cryptoderp

;DEMONSTRATION
;
; run in 0x10co.de
;
;Here we will do as follows.
;input a single key of length 8
;create a DARKFOUR table of length 256 using the key;generate another table using the same key, as if
; there were two separate ships using the same
; cypher key. (Each ship only needs one table
; to communicate with another ship using a table
; built with the same key.)
;input some plaintext ("plaintext")
;use the use DARKFOUR cypher algorithm on the
; plaintext, giving it only the location of the
; table (and the values of I and J, which are
; both 0 to start with, in this 1-transmission
; test case.)
;copy the cyphertext
;use the DARKFOUR algorithm, using the second
; table, on the cyphertext, as if it were another
; ship decrypting a transmission.
;NOTE
;If one tried to decrypt the cyphertext generated by
; the first ship using the first ship's table,
; (rather than generating a new one from the same
; key,) one would encypher the plaintext again.
; (Doing so, unfortunately, would make decyphering
; it very inconvenient for the recieving party.)

SET [0x4FF8], 0xe5 ;keybyte 0
SET [0x4FF9], 0x8a
SET [0x4FFA], 0x91
SET [0x4FFB], 0x0F
SET [0x4FFC], 0xbc
SET [0x4FFD], 0xd9
SET [0x4FFE], 0xc5
SET [0x4FFF], 0x37 ;keybyte 7

SET [0x8000], 0xF070 ;"plaintext"
SET [0x8001], 0xF06C
SET [0x8002], 0xF061
SET [0x8003], 0xF069
SET [0x8004], 0xF06E
SET [0x8005], 0xF074
SET [0x8006], 0xF065
SET [0x8007], 0xF078
SET [0x8008], 0xF074

SET A, 0x4FF8
SET B, 8
SET C, 0x5000
JSR init_DARKFOUR

SET A, 0x4FF8
SET B, 8
SET C, 0x5100
JSR init_DARKFOUR

SET A, 0x8000
SET B, 9
SET C, 0x5000
JSR DARKFOUR

SET [0x8040], [0x8000]
SET [0x8041], [0x8001]
SET [0x8042], [0x8002]
SET [0x8043], [0x8003]
SET [0x8044], [0x8004]
SET [0x8045], [0x8005]
SET [0x8046], [0x8006]
SET [0x8047], [0x8007]
SET [0x8048], [0x8008]

SET A, 0x8040
SET B, 9
SET C, 0x5100
JSR DARKFOUR

SET PC, EOF


:DARKFOUR ; (dataloc, datalen, tableloc)
SET PUSH, X
SET PUSH, Y
SET PUSH, I
SET PUSH, J

ADD B, A ;make B the endpoint of the target data

SET I, 0
SET J, 0

:DARKFOUR_loop
;table lookup
AND I, 0x00FF
BOR I, C     ;make I an index in the table

ADD J, [I]
AND J, 0x00FF
BOR J, C     ;make J an index in the table

SET Y, [I]
ADD Y, [J]   ;set Y to [I] + [J]

SET X, [I]
SET [I], [J]
SET [J], X   ;switch [I] and [J]

ADD I, 1     ;iterate I

AND Y, 0x00FF
BOR Y, C     ;make Y an index in the table
;end table lookup

XOR [A], [Y]       ;encypher
ADD A, 1           ;iterate
IFG B, A
SET PC, DARKFOUR_loop

SET J, POP
SET I, POP
SET Y, POP
SET X, POP
SET PC, POP ;DARKFOUR


:init_DARKFOUR ; (keyloc, keylen, tableloc)
SET PUSH, I
SET PUSH, J
SET PUSH, Z

SET PUSH, B	;store keylen

SET I, A
ADD B, A
SET Z, 0
:init_DARKFOUR_highbyte ; make the high byte
ADD Z, [I]
ADD I, 1
IFG B, I
SET PC, init_DARKFOUR_highbyte
;end highbyte

SET B, C	;reuse B
ADD B, 0xFF	;make B the table end loc

SET I, 0
SET J, 0

:init_DARKFOUR_maketable ; initialize table
AND I, 0x00FF
BOR I, C
SET [I], Z
ADD Z, 0x0101
ADD I, 1
IFG B, I
SET PC, init_DARKFOUR_maketable

SET B, POP	;retrieve
SUB B, 1	;start len at 0

SET I, 0
SET J, 0
:init_DARKFOUR_usekey ; make bytes
BOR I, C    ;make I an index on the table

ADD J, [I]   ;begin assembling J

SET Z, I     ;get key byte
AND Z, B     ;
BOR Z, A

ADD J, [Z]   ;add key byte

AND J, 0x00FF
BOR J, C     ;make J an index on the table

SET Z, [I]   ;swap values I and J
SET [I], [J]
SET [J], Z

ADD I, 1     ;increment I
AND I, 0x00FF;make I easy to compare
IFG 0x00FF, I;continue if I has not reached
SET PC, init_DARKFOUR_usekey ;the end of the table

SET Z, POP
SET J, POP
SET I, POP
SET PC, POP ;init_DARKFOUR

:EOF SET PC, EOF
